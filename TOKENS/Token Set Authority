# TOKEN SET AUTHORITY
# Mint Account Authorities
# Mint Authority: Controls the creation of new tokens. Can mint tokens to any token account. Often revoked 
# after initial supply is created to create a fixed supply token
# Freeze Authority: Controls the ability to freeze and thaw token accounts. Can prevent any token account from transferring tokens. Often revoked to guarantee users their tokens cannot be frozen

# TOKEN ACCOUNT AUTHORITIES
# Account Owner: Has full control over the token account. Can transfer tokens, burn tokens, approve delegates, and close the account when the balance is zero
# Close Authority: Can close the token account when the balance is zero. By default, this is the account owner but can be delegated to another account

# SET AUTHORITY
# The SetAuthority instruction changes or revokes authorities on mints and token accounts
#  Only the current authority, can transfer their permissions to a new address or revoke  them permanently by setting the authority to null. Once revoked, the authority cannot be revoked

# RUST ASYNC
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, set_authority, AuthorityType},
    state::Mint,
};
#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //Generate a new keypair for the new_authority
    let new_authority = Keypair::new();
    //Airdrop 1 SOL to new fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as address
    let mint = Keypair::new();
    //Get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),  //payer
        &mint.pubkey(), //new mint account
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program_id
    );

    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(), //
        &mint.pubkey(),//mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9, //decimals
    )?;

    //Calculate the associated token account
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program_id
    );
    //instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );
    //Create transaction  and add instruction
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );
    //Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Mint Address: {}", mint.pubkey());
    println!("New Authority Address: {}", new_authority.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);
    //Get the latest blockhash for the  authority change transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Change Mint Authority(MintToken)
    let set_mint_authority_ix = set_authority(
        &token_program_id(), //program id
        &mint.pubkey(), //mint account
        Some(&new_authority.pubkey()), //new authority
        AuthorityType::MintTokens//authority Type
        &fee_payer.pubkey(), //current authority
        &[&fee_payer.pubkey()], //signers
    )?;

    //2. Change freeze authority(FreezeAccount)
    let set_freeze_authority_ix = set_authority(
        &token_program_id(), //program id
        &mint.pubkey(), //mint account
        Some(&new_authority.pubkey()), //new authority
        AuthorityType::FreezeAccount, //authority type
        &fee_payer.pubkey(), //current authority
        &[&fee_payer.pubkey()], //signers
    )?;

    //Create transaction for authority changes
    let transaction = Transaction::new_signed_with_payer(
        &[set_mint_authority_ix, set_freeze_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;


    println!("\nSuccessfully changed mint and freeze authorites to: {}", new_authority.pubkey());
    println!("Transaction Signature: {}", transaction_signature);
    //Get the latest blockhash for revoke transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Example of revoking authority(setting to null)
    let revoke_mint_authority_ix = set_authority(
        &token_program_id(), //program id
        &mint.pubkey(), //mint account
        None, //new authority
        AuthorityType::MintTokens, //authority types
        &new_authority.pubkey(), //current authority
        &[&new_authority.pubkey()], //signers
    )?;

    //Create transaction for revoking
    let transaction = Transaction::new_signed_with_payer(
      &[revoke_mint_authority_ix],
      Some(&fee_payer.pubkey()), 
      &[&fee_payer, &new_authority], //new authority needs to sign
      latestBlockhash, 
    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("\nSucessfully revoked mint authority");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```
# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,

};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, set_authority, AuthorityType},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()>{
    //create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await;
    //Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();
    //Generate a new keypair for the new authority
    let new_authority = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }
    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Get default mint account size(in bytes) no extensions enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new account(mint)
        mint_rent //lamports
        mint_space as u64 //space
        &token_program_id(), //program_id,
    ),
    //Instructions to initialize mint  account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9, //decimals
    )?;

    //Calculate the associated token account address for the fee_payer
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );
    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );
    //Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash, 
    ),
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&airdrop_signature).await?;
    println!("Mint Address: {}", mint.pubkey());
    println!("New Authority Address: {}", new_authority.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);
    //get the latest blockhash  for the authority change transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //1: Change Mint Authority
    let set_mint_authority_ix = set_authority(
        &token_program_id(), //program id
        &mint.pubkey(), //mint account
        Some(&new_authority.pubkey()), //program id
        AuthorityType::MintTokens, //authority type
        &fee_payer.pubkey(), //current authority
        &[&fee_payer.pubkey()], //signers
    )?;
    //Change Freeze Authority
    let set_freeze_authority_ix = set_authority(
    &token_program_id(), //program id
    &mint.pubkey(), //mint account
    Some(&new_authority.pubkey()), //new authority
    AuthorityType::FreezeAccount//authority type
    &fee_payer.pubkey(), //current authority
    &[&fee_payer.pubkey()], //signers
    )?;

    //Create a transaction for the authority changes
    let transaction = Transaction::new_signed_with_payer(
    &[set_mint_authority_ix, set_freeze-authority_ix],
    Some(&fee_payer.pubkey()),
    &[&fee_payer],
    latestBlockhash
    );

    //send and confirm transaction 
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await;
    println!(
        "\nSuccessfully changed mint and freeze authorities to: {}",
        new_authority.pubkey()
    );
    println!("Transaction Signature: {}", transaction_signature);
    //Get the latest blockhash for the revoke transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Revoking Authority(setting to null)
    let revoke_mint_authority_ix = set_authority(
        &token_program_id(), //program id
        &mint.pubkey(), //mint account
        None, // New authority(None to revoke),
        AuthorityType::MintTokens, //authority type
        &new_authority.pubkey(), //current authority
        &[&new_authority.pubkey()], //signers
    )?;

    //Create transaction for revoking
    let transaction = Transaction::new_signed_with_payer(
        &[revoke_mint_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &new_authority], //new authority needs to sign
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = token
    .set_authority(
        &associated_token_address, //token account
        &payer.pubkey(), // current authority
        Some(&new_authority.pubkey()), //new authority
        AuthorityType::CloseAccount,  //authority type
        &[&payer], //signing keypairs
    )
    .await?;

     println!(
        "\nSuccessfully changed close  authority for token account to: {}",
        new_authority.pubkey()
     );

     println("Transaction Signature: {}", transaction_signature);
     Ok(())
}
```