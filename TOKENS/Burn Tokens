# BURN TOKENS
# The BurnChecked instruction permanently destroys tokens  by reducing balance in the token account
# Burned tokens are removed from circulation and decreases the supply tracked on the mint account
# Only the token account owner can burn the tokens from their account

# Rust Async
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::created_associated_token_account,

};

use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, mint_to, burn_checked},
    state::{Mint, Account as TokenAccount},
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
     String::from("http://localhost:8899"),
     CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;

    //Generate a new keypair for the fee
    let fee_payer = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    ///Instruction to create a new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new account(mint)
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id

    );
    //Instructions to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9; //decimals
    )?;

    //Calculate the associated token account address for a fee payer
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(),//owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );

    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
       &fee_payer.pubkey(); //funding address
       &fee_payer.pubkey();//wallet address
       &mint.pubkey(); //mint address
       &token_program_id(); //program id
    );

    //Amount of tokens to mint(1000 token)
    let amount = 1000_000_000_000;

    //Create mint_to instruction to mint
    let mint_to_instruction = mint_to(
        &token_program_id(),
        &mint.pubkey(), //mint
        &associated_token_address, //destination
        &fee_payer.pubkey(), //authority
        &[&fee_payer.pubkey()] //signer
        amount, //amount
    )?;

    //Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_account_instruction,
            create_ata_instruction,
            mint_to_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    //Send and confirm transaction
    let transaction_signature =client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Associated Token Account Address: {}"
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);
    println!("Successfully minted 1000.00 tokens");
    //Fetch token account to check balance before burn
    let token_account_data = client.get_account(&associated_token_address).await?;
    let token_account = TokenAccount::unpack(&token_account_data.data)?;
    println!("\n Token Balance before burn: {} tokens", token_account.amount as f64 / 1_000_000_000.0);
    //Get the latest blockhash for the burnt transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Amount of tokens to burn
    let burnt_amount = 10_000_000_000;

    //Create burn checked instruction
    let burnt_instruction = burn_checked(
        &token_program_id(),
        &associated_token_address,
        &mint.pubkey(),
        &fee_payer.pubkey(),
        &[&fee_payer.pubkey()],
        burn_amount,
        9;
    )?;
    //Create transaction for burning tokens
    let transaction = Transaction::new_signed_with_payer(
        &[burn_instruction],
        Somr(&fee_payer.pubkey()),
        &[&fee_payer()],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    //Fetch token account to check balance after burn
    let token_account_data = client.get_account(&associated_token_address).await?;
    let token_account = TokenAccount::unpack(&token, account_data.data)?;
    println!("Token balance after burn: {} tokens", token_account.amount as f64 / 1_000_000_000.0);

    println!("\nSuccessfully burned 10.0 tokens");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())

}
```

# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},
};

use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    //Generate a new keypair for the fee payer
    let payer = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );
    //Number of decimals for the mint
    lt decimals = 9;

    //Create a Token client for a Token Program
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
    );

    //Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params //no extensions
        &[&mint] //mint keypair needed as signer
    )
    .await?;

   println!("Mint Address: {}", mint.pubkey());
   println!("Mint Creation Result: {}", mint_result);

   let associated_token_address = token.get_associated_token_address(&payer.pubkey());
   println!(
    "Associated Token Account Address: {}"
    associated_token_address
   );

   //Then create the associated token account
   let create_ata_result = token
   .create_associated_token_account(
    &payer.pubkey(), //owner
   )
   .await?;
println!("Created Associated Token Account: {}", create_ata_result);

//Mint tokens to the associated token account
  let amount = 1000_000_000_000;
  let mint_to_result = token
  .mint_to(
    &associated_token_address//destination
    &payer.pubkey(), //mint authority
    amount, //amount
    &[&payer], // additional signer payer as signer
  )
  .await?;

println!("Successfully minted 1000.0 tokens to associated token account");
println!("Transaction Signature: {}", transaction_signature);

//Fetch token account to check balance
let token_account_before = token.get_account_info(&associated_token_address).await?;
println!(
    "Token balance before burn: {} tokens",
    token_account_before.base.amount / 10_u64.pow(decimals as u32)
);

//Burn 10 tokens from the associated token account
let burn_amount = 10_000_000_000;
let burn_result = token
.burn(
    &associated_token_address, //source token account
    &payer.pubkey(), //authority
    burn_amount, //amount
    &[&payer]//signers
)
.await?;

// Fetch token account to check balance after burn
let token_account_after = token.get_account_info(&associated_token_address).await?;
println!(
    "Token balance after burn: {} token",
    token_account_after.base.amount / 10_u64.pow(decimals as u32)

);

println!("\nSuccessfully burned 10.0 tokens");
println!("Transaction Signature: ", transaction_signature);

Ok(())
}
```