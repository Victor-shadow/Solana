# APRROVE DELEGATE

# The ApproveChecked instruction grants another account (the delegate) permission to transfer a specific amount of tokens from a token account.
# The delegate can transfer tokens up to the approved amount, but cannot exceed it. Only the token account owner can approve the delegate, and each token account can have only one delegate at a time. Any new approval overwrites the previous one

# RUST ASYNC
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, mint_to, aprrove_checked},
    state::Mint,
};
#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();

    //Generate a new keypair for the delegate
    let delegate = Keypair::new();

    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed{
            break;
        }
    }
    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Get default Mint Account Size
    let mint_space = Mint::LEN;
    let mint_rent = client.get_minimum_balance_for_rent_exemption(mint_space).await?;

    //Instruction to create a new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //mint account
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    );
    //Instructions to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(),//mint authority
        Some(&fee_payer.pubkey()),//freeze authority
        9,//decimals
    )?;

    //calculate the associated token account address for fee_payer
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program_id,
    );

    //Instruction to create associated token
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );
    //Amount of tokens to mint(1000 tokens with 9 decimals)
    let mint_to_instruction = mint_to(
        &token_program_id(),
        &mint.pubkey(), //mint
        &associated_token_address, //destination
        &fee_payer.pubkey(), //authority
        &[&fee_payer.pubkey()], //signer
        amount, //amount
    )?;

    //Create transaction and add instruction
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
            mint_to_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latest_blockhash,
    );

    //Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address,
    );
    println!("\nTransaction Signature: {}", transaction_signature);
    //Get the latest blockhash for the aprrove transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Amount of tokens to approve
    let approve_amount = 1_000_000_000;
    //Create approved checked instruction
    let approve_instruction = approve_checked(
        &token_program_id(), //program id
        &associated_token_address, //source token account
        &mint.pubkey(), //mint
        &delegate.pubkey(), //delegate
        &fee_payer.pubkey(), //owner
        &[&fee_payer.pubkey], //signers
        approve_amount,//amount
        9,//decimals
    )?;
    //Create transaction for approving delegate
    let transaction = Transaction::new_signed_with_payer(
        &[approve_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("\nDelegate Address: {}", delegate.pubkey());
    println!(
        "Successfully approved delegate to transfer 1.0 tokens"
    );

    println!("Transaction Signature: {}", transaction_signature);

    Ok(())

}
```

# TOKEN CLIENT
```rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig;
    signature::{Keypair, Signer},
};

use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the feepayer
    let payer = Keypair::new();
    //Generate a keypair for the delegate 
    let delegate = Keypair::new();
    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop{
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed{
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed();
        )),
        ProgramRpcClientSendTransaction,
    );

    //Number of decimals for the mint
    let decimals = 9;
    //create a token client for the token program
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
    );

    //Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token 
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params, //no extension
        &[&mint], //mint keypair needed as signers
    )
    .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Create mint Account: {}", mint_result);

    //derive the associated token
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address:{} ",
        associated_token_address
    );

    //Create the associated token
    let create_ata_result = token
    .creat_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;

    println!("Created Associated Token Account:{} ", create_ata_result);
    //Mint tokens to the associated token account
    let amount = 1000_000_000_000; //1000 tokens with 9 decimal places
    let mint_to_result = token
    .mint_to(
        &associated_token_address, //destination,
        &payer.pubkey(), //mint authority
        amount, //amount
        &[&payer] //additional signers(providing payer with signer)
    )
    .await?;
    println!("\nMinted 1000.0 tokens to associated token account");
    println!("Mint Transaction: {}", mint_to_result);

    //Approve delegates to transfer 1 token
    let delegated_amount = 1_000_000_000;
    let approve_result = token
    .approve(
        &associated_token_address,
        &delegate.pubkey(),
        &payer.pubkey(),
        delegated_amount,
        &[&payer],
    )
    .await?;

    println!("\nDelegate Address: {}", delegate.pubkey());
    println!(
        "Successfully approved delegate to transfer 1.0 tokens",
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```