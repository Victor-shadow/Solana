# TOKEN ACCOUNT

# A token account stores a balance of a specific token. Each token account is associated exactly one mint and tracks one's token balance and additional details

``` rust
/// Account data
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    ///The mint associated with the account
    pub mint: Pubkey,
    /// the owner of the account
    pub owner: Pubkey,
    /// The amount of tokens the account has
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents the
    /// amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    ///This account's state
    pub state: AccountState,
    ///If `is_native.is_some`, this is a native token, and the value logs the 
    /// rent-exempt reserve. An account is required to be rent-exempt, so the value
    /// is used by the Processor to ensure that the wrapped SOL
    /// accounts do not drop below this threshold
    pub is_native: COption<u64>,
    /// The amount delegated
    pub delegated_amount: u64,
    ///Optional authority to close the account
    pub close_authority: COption<Pubkey>,
}
```
# To hold tokens, one needs a token account for that specific mint. Each token account tracks:
# 1: Mint: The specific token type it holds
# 2: Owner: The authority who can transfer tokens from this account

# Associated Token Account
# An Associated Token Account(ATA) is the default token account for a wallet to hold a specific token
# It uses a determinstic address(PDA) created by the Associated Token Program
# Associated Token Account use deterministic addresses , making it easy to find any wallet's token account for a given mint
# Only token accounts created by the AssociatedTokenProgram are called "associated token accounts"

# The term "owner" can be used in two different contexts:
# 1: Token Account Owner: The authority who can transfer, burn or delegate tokens. This is stored in the token account's data
# 2: Program Owner: The program that owns the account(always the Token Program or Token Extension Program) for token accounts
# When working with token accounts, "owner" typically refers to the authority that can transfer tokens, not the program that owns the account

``` rust
pub fn get_associated_token_address_and_bump_seed_internal(
    wallet_address: &Pubkey,
    token_mint_address: &Pubkey,
    program_id: &Pubkey,
    token_program_id:&Pubkey,
) -> (Pubkey, u8) {
    Pubkey::find_program_address(
        &[
            &wallet_address.to_bytes(), //Owner public key
            &token_program_id.to_bytes(), // Token Program or Token Extension Program
            &token_mint_address.to_bytes(), //Token mint address
        ],
        program_id, //Associated TokenProgramID
    )
}
```

# The Associated Token Account is a helper that:
# 1: Creates token accounts at deterministic addresses(PDA)
# 2: Makes Cross Program Invocations to the Token Program
# 3: Does not maintain state itself
# The resulting token accounts are owned by the Token Program and use the Standard Account Structure


# For any wallet and token combination, there is exactly one Associated Token Address. This eliminates the need to track token account addresses manually - one can always derive the correct address

# CREATE A TOKEN ACCOUNT
# Creating a token account requires the InitializeAccount instructions
# One needs two instructions to create a token account:
# System Program: Create an account with allocated space for a token account and transfer ownership to the Token Program
# Token Program: Initialize the token account data

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_token::{
    id as token_program_id,
    instruction::{initialize_account, initialize_mint},
    state::{Account, Mint},
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::Confirmed(),

    );

    let latest_blockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new(),

    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000),
    .await?;

    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate Keypair to use as an Address
    let mint = Keypair::new();

    //Get default Mint Account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

  //Instruction to create a new account for mint(token program)
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new account(mint)
        mint_rent, //lamport
        mint_space as u64, //space
        &token_program_id(), //program_id
    );

    //Instructions to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), // mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        2, //decimals
    )?;

    //create transaction and add instruction
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    ) ;

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("MintAddress: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);
    //Generate keypair to use as an address
    let token_account = Keypair::new();

    //Get token account size(in bytes)
    let token_account_space = Account::LEN;
    let token_account_rent = client
    .get_minimum_balance_for_rent_exemption(token_account_space)
    .await?;

    //Instruction to create new account for token account(token program)
    let create_token_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &token_account.pubkey(), //new account
        token_account_rent, //lamports
        token_account_space as u64, //space
        &token_program_id(), //program id
    );

    //Instruction to initialize token account data
    let initialize_token_account_instruction = initialize_account(
        &token_program_id(),
        &token_account.pubkey(), //account
        &mint.pubkey(), //mint 
        &fee_payer.pubkey(), //owner
    )?;

    //create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_token_account_instruction,
            initialize_token_account_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &token_account],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Token Account Address: {}", token_account.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())

}
```

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams},
};
use std::sync::Arc;
#[tokio::main]
async fn main() -> Result<()>{
    //create connection with local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("https://localhost:8899"),
        CommitmentConfig.confirmed(),
    );

    //Generate a new keypair for the fee_payer
    let payer = Keypair::new();

    //Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }
    //Generate new Keypair to use as an address
    let mint = Keypair::new();
    //Create a new Program Client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    //Number of decimals for the mint
    let decimals = 2;

    //Create a token client for the Token Program
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
    );

    //Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams>

    let mint_result = token
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params, //no extensions
        &[&mint], //mint keypair needed as signer
    )
    .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("{}", mint_result);

    //Generate keypair for the token account
    let token_account_keypair = Keypair::new();

    //Create token account using the keypair
    let token_account_result = token
    .create_auxilary_token_account(
        &token.account_keypair, //account_keypair
        &payer.pubkey(), //owner
    )
    .await?;

   println!("Token Account Address: {}", token_account_result);
   Ok(())
}
```

# Create an Associated Token Account
#  Creating the Associated Token Account(ATA) requires the Create instruction
# The Single instruction automatically handles creating the token account and initializing it through the Cross Program Invocation

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,

};
use spl_token::{id as token_program_id instruction::initialize_mint, state::Mint};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899");
        CommitmentConfig::confirmed(),
    );

    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate new keypair for the fee payer
    let fee_payer = Keypair::new();

    //Airdrop 1 SOL to payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
     client.confirm_transaction(&airdrop_signature).await?;

     loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
     }

     //Generate keypair to use as an address
     let mint = Keypair::new();
     //Get default mint account size
     let mint_space = Mint::LEN;
     let mint_rent = client
     .get_minimum_balance_for_rent_exemption(mint_space)
     .await?;

    //Instruction to create a new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //account(mint)
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    );
    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        2, //decimal
    )?;
    //Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    //Get the lates blockhash
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Derive the associated  token account address for the fee_payer
    let associated_token_account = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(),//owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );

    //Instruction to create associatd token account
    let create_ata_instruction = create_associated_token_account(
       &fee_payer.pubkey(),  //funding address
       &fee_payer.pubkey(), //wallet address(owner)
       &mint.pubkey(), //mint address
       &token_program_id(), program id
    );

    //Create transaction for associated token account creation
    let transaction = Transaction::new_signed_with_payer(
        &[create_ata_instruction],
        Some(&fee_payer.pubkey()), //
        &[&fee_payer],
        latestBlockhash,
    );

    //Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!(
        "Associated Token Account Address: {}",
        associated_token_account.to_string(),
    );

    println!("Transaction Signature: {}", transaction_signature);
    Ok(())
}
```

# Token Client
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair,Signer},
};

use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},

};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new Keypair for the fee_payer
    let payer = Keypair::new();

    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
   rpc_client.confirm_transaction(&airdrop_signature).await?;

     loop {
        let confirmed = rpc_client.confirm_and_send_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
     }

     //Generate keypair to use as a address
     let mint = Keypair::new();
     //Create a new Program Client
     let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("https://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
     );
     
     //Number of decimals for the mint
     let decimals = 2;

     //Create a TokenClient for the TokenProgram
     let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
     );

     //Create and Initialize the mint
     let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

     let mint_result = token
     .create_mint(
        &payer.pubkey(),
        Some(&payer.pubkey()),
        extension_initialization_params,
        &[&mint],
     )
     .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("{}", mint_result);

    //Derive the associated token account address
    let associated_token_account_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );

    //Create associated token account for the payer
    let result = token
    .create_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;

    println!("{}", result);

    Ok(())
}
```