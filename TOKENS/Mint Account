# TOKEN ACCOUNT 

# A token account stores balance of a specific token
# Each token account is associated with exactly one mint and tracks one token balance and additional details

``` rust
///Account data
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    /// The mint associated with this account
    pub mint: Pubkey,
    ///The owner of the account
    pub owner: Pubkey,
    /// The amount of tokens this account holds
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    ///The account's state
    pub state: AccountState,
    ///If `is_native.is_some`, this is a native token, and the value logs the
    /// rent-exempt reserve. An account is required to be rent-exempt, so the value is used by the 
    /// Processor to ensure that wrapped SOL
    /// accounts do not drop below this threshold
    pub is_native: COption<u64>,
    ///the amount delegated
    pub delegated_amount: u64,
    ///Optional authority to close the account
    pub close_authority: COption<Pubkey>,
}
```
# NOTE: Developers call a Token account an Account type
# Both the Token Program and Token Extension Program share the same base implementation for the Token Account

# To hold tokens, one needs a token account for that specific mint. Each token account tracks:
# Mint: The specific token type it holds
# Owner: The authority who can transfer tokens from this account
# The term owner can be used in two different contexts:
# 1: Token Account Owner: The authority who can transfer, burn or delegate tokens. This is stored in the token account's data
# 2: Program Owner: The program that owns the account(always the Token Program or the Token Extension Program for token accounts)
# When working with token accounts, "owner" typically refers to the authority that can transfer tokens, not the program that owns the account

# ASSOCIATED TOKEN ACCOUNT
# An Associated Token Account(ATA)It is a default token account for a wallet to hold a specific token
# It uses a deterministic address Program Derived Address created by the Associated Token Program
# Only Token Accounts created by the Associated Token Program are called "associated token accounts"

# ATA's use deterministic addresses, making it easy to find any wallet's token account for a given mint

``` rust
pub fn get_associated_token_address_and_bump_seed_internal(
    wallet_address: &Pubkey,
    token_mint_address: &Pubkey,
    program_id: &Pubkey,
    token_program_id: &Pubkey,
) -> (Pubkey, u8) {
    Pubkey::find_program_address(
        &[
            &wallet_address.to_bytes(), //Owner's public key
            &token_program_id.to_bytes(), //Token Program or Token Extension Program
            &token_mint_address.to_bytes(), //Token Mint Address 
        ],
        program_id, //Associated Token ProgramID
    )
}
```

# For any wallet and token combination, there is exactly one ATA Address. This eliminates the need to track account addresses manually - one can always derive the correct address
# The Associated Token Program is a helper that:
# 1: Creates token accounts at deterministic addresses(PDAs)
# 2: Makes Cross Program Invocations to the Token Program
# 3: Does not maintain any state itself
# The resulting token accounts are owned by the Token Program and use the Standard Account Structure

# Create a Token Account requires the InitializeAccount instruction
# On needs two instructions to create a token account:
# 1 System Program: Creates an account with allocated space for a token account and transfer ownership to the Token Program
# 2: Token Program: Initialize the token account data

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_token::{
    id as token_program_id,
    instruction::{initialize_account, intialize_mint},
    state::{Account, Mint},
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let latest_blockhash = client.get_latest_blockhash().await?;
    //generate a new keypair for the fee payer
    let fee_pair = Keypair::new();

    //Airdrop ` 1 SOL ` To the fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address of mint
    let mint = Keypair::new();

    //get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create a new account for mint(token account)
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new accounht(mint)
        mint_rent, //lamports
        mint_space as u64, //space
        //program id
        &token_program_id(),

    );

    //Instructions to initialize mint account data
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        2, //decimals
    )?;

    //create transactions and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    //Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}",transaction_signature);

    //generate keypair to use as address
    let token_account = Keypair::new();

    //get token account size
    let token_account_space = Account::LEN;
    let token_account_rent = client
    .get_minimum_balance_for_rent_exemption(token_account_space)
    .await?;

    //instruction to create new account
    let create_token_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &token_account.pubkey(), //new accounts (token account)
        token_account_rent, //lamports
        token_account_space as u64, //space
        &token_program_id(), // program id
    );

    //instruction to initialize token account
    let initialize_token_account_instruction = initialize_account(
        &token_program_id,
        &token_account.pubkey(), //account
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //owner
    )?;
    //create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_token_account_instruction,
            initialize_token_account_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &token_account],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Token Account Address: {}", token_account.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```
# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};

use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},
};

use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the fee_payer
    let payer = Keypair::new();

    //Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate Keypair to use as an Address
    let mint = Keypair::new();
    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    //Number of decimals for the mint
    let decimals = 2;

    //Create a token client for the Token Program
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(player.insecure_clone()),

    );

    //Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params, //no extensions
        &[&mint], //mint keypair needed as signer
    )
    .await?;

   println!("Mint Address: {}", mint.pubkey());
   println!("{}", mint_result);

   //Generate keypair for the token account
   let token_account_keypair = Keypair::new();

   //Create a token account using the keypair
   let token_account_result = token
   .create_auxilary_token_account(
    &token_account_keypair, //account_keypair
    &payer.pubkey(), //owner
   )
   .await?;

println!("Token Account Address: {}", token_account_result);
Ok(())
}
```

# CREATE AN ASSOCIATED TOKEN ACCOUNT
# Creating an Associated Token Account(ATA),requires the Create instruction.
# This Single Instruction automatically handles creating the token account and initializing it through the Cross Program Invocations(CPI)

``` rust 
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::creat_associated_token_account,

};
use spl_token::{id as  token_program_id, instruction::initialize_mint, state::Mint},

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection with local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        )
        CommitmentConfig::confirmed(),
    );
    let blockhash = client.get_latest_blockhash().await?;

    //Generate a new Keypair for the fee_payer
    let fee_payer = Keypair::new();

    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as address
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    //Create Account Instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),
        &mint.pubkey(),
        rent,
        space as u64,
        &token_program_id(),
    );

    ///Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(),
        &fee_payer.pubkey(),
        Some(&fee_payer.pubkey()),
        9,

    )?;
    //Create transaction and add instruction
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("\nTransaction Signature: {}", transaction_signature);

    Ok(())
}
```

# NOTE: USD Coin(USDC) has the mint address: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
# This address uniquely identifies USDC throughout the solana ecosystem
