# Token Transfrs move tokens between token accounts of the same mint using the TransferChecked instruction
# Both token accounts must hold the same token type
# Only the source account delegate or owner can authorize transfers

# Rust Async
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,

};
use spl_token::{
    id as token program_id,
    instruction::{initialize_mint, mint_to, transfer_checked},
    state::Mint,
};

#[tokio::main]
async fn main -> Result<()> {
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the feepayer
    let fee_payer = Keypair::new();
    //Generate a second keypair
    let recipient = Keypair::new();

    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use address as mint
    let mint = Keypair::new();

    //Get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new account(mint)
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    );

    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        2; //decimals
    )?;

    //calculate the associated token account
    let source_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );

    //instruction to create associated token account for fee_payer
    let create_source_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), // funding address
        &fee_payer.pubkey(), // wallet address
        &mint.pubkey(), // mint address
        &token_program_id(), // program id
    );

    //Create the associated token account address for the recipient
    let destination_token_address = get_associated_token_address_with_program_id(
        &recipient.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program_id
    );

    //Instruction to create associated token account for the recipient
     let create_destination_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &recipient.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
     );

     //Amount of tokens to mint
     let amount = 100_00;

     //create mint_to instruction to mint token to the source token account
     let mint_to_instruction = mint_to(
        &token_program_id(),
        &mint.pubkey(),//mint
        &source_token_address,//destination
        &fee_payer.pubkey(),//authority
        &[&fee_payer.pubkey()],//signer
        amount, //amount
     )?;

     //Create transaction and add instruction
     let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_source_ata_instruction,
            create_destination_ata_instruction,
            mint_to_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
     );

     //send and confirm transaction
     let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

     println!("Mint Address: {}", mint.pubkey());
     println!("Source Token Account Address: {}", source_token_address);
     println!(
        "Destination Token Account Address: {}",
        destination_token_address
     );
     println!("Setup Transaction Signature: {}", transaction_signature);
     println!("Minted {} tokens to the source token account", account);

     //Get the latest blockhash for the transfer transaction
     let latestBlockhash = client.get_latest_blockhash().await?;
     //Amount of tokens to transfer
     let transfer_amount = 50;
     //Create transfer_checked instructions to send token from source to destination
     let transfer_instruction = transfer_checked(
        &token_program_id(), //program id
        &source_token_address, //source
        &mint.pubkey(), //mint
        &destination_token_address, //destination
        &fee_payer.pubkey(),//owner of the source
        &[&fee_payer.pubkey()], //signers
        transfer_amount, //amount
        2, //decimal
     )?;   

     //create transaction for transferring tokens
     let transaction = Transaction::new_signed_with_payer(
        &[transfer_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
     );
     //send and confirm transaction
     let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
     println!(
        "Successfully transferred 0.50  tokens from sender to recipient"
     );

     println!("Transaction signature: {} ", transaction_signature);
     //Get token account balances to verify the transfer
     let source_token_account = client.get_token_account(&source_token_address).await?;
     let destination_token_account = client..get_token_account(&destination_token_address).await?;

     if let Some(source_account) = source_token_account {
        println!(
            "Source Token Account Balance: {} tokens",
            source_account.token_amount.amount

        );
     }

     if let Some(destination_amount) = destination_token_amount{
        println!(
            "Destination Token Account Balance: {} tokens",
            destination_account.token_amount.amount,
        );
     }

     Ok(())
}
```

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig;
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token};
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Create a new keypair for the fee_payer
    let payer = Keypair::new();
    //Generate a second Keypair for the token recipient
    let recipient = Keypair::new();
    //Airdrop 1 SOL TO fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Airdrop 1 SOL to recipient for rent exemption
    let recipient_airdrop_signature = rpc_client
    .request_airdrop(&recipient.pubkey(), 1_000_000_000)
    .await?;
     rpc_client
     .confirm_transaction(&recipient_airdrop_signature)
     .await?;

    loop {
        let confirmed = rpc_client
        .confirm_transaction(&recipient_airdrop_signature)
        .await?;
    if confirmed {
        break;
    }
}

  //Generate keypair to use as address
  let mint = Keypair::new();
  //Create a new program, token
  let program_client = ProgramRpcClient::new(
    Arc::new(RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed()
    )),
    ProgramRpcClientSendTransaction,
  );

  //number of decimals for the mint
  let decimals  = 2;
  //Create a token client for the Token
  let token = Token::new(
    Arc::new(program_id),
    &token_program_id(),
    &mint.pubkey(),
    Some(decimals),
    Arc::new(payer.insecure_clone()),
  );

  //Create and initialize the mint
  let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

  let mint_result = token
  .create_mint(
    &payer.pubkey(), //mint authority
    Some(&payer.pubkey()), //freeze authority
    extension_initialization_params, //no extensions
    &[&mint], //mint keypair needed as a signer
  )
  .await?;

  println!("Mint Address: {}", mint.pubkey());
  println!("Mint Creation Result: {}", mint_result);

  let source_token_address = token.get_associated_token_address(&payer.pubkey());
  println!("Source Token Account Address : {}", source_token_address);

  //Create an associated token account for payer
  let create_source_ata_result = token
  .create_associated_token_account(
    &payer.pubkey(),
  )
  .await?;
   println!("Created Source Token Account: {}", create_source_ata_result);
   //Derive the associated token account
   let destination_token_address = token.get_associated_token_address(&recipient.pubkey());
   println!(
    "Destination Token Account Addresses: {}",
    destination_token_address
   );

   //Create the associated token account
   let create_dest_ata_result = token
   .create_associated_token_account(
    &recpient.pubkey(), //owner
   )
   .await?;
   println!(
    "Created Destination Token Account: {}",
     create_dest_ata_result
   );

   //Mint tokens to the associated  token
   let mint_amount = 100;
   let mint_to_result = token
   .mint_to(
    &source_token_address, //destination
    &payer.pubkey(), //mint authority
    mint_amount, //amount
    &[&payer] //additional signer providing payer
   )
   .await?;

println!("Successfully minted 1.00 as tokens to the associated token account");
println!("Transaction Signature: {}", transaction_signature);
   //Transfer tokens from Source to destination
    let transfer_amount = 50 //0.50 tokens with 2 decimals
    let transaction_signature = token
    .transfer(
        &source_token_address, //source
        &destination_token_address, //destination
        &payer.pubkey(), //owner of source
        transfer_amount, //amount
        &[&payer], //additional signers
    )
    .await?;

    println!(
        "Successfully transfered {} tokens from sender to recipient",
        transfer_amount,
    );
    println!("Transaction Signature: {}", transaction_signature);
    //Get token account balances to verify transfer
    let source_balance = token.get_account_info(&source_token_address).await?;
    println!(
        "Source Token Account Balance: {} tokens",
        source_balance.base.amount
    );

    let destination_balance = token.get_account_info(&destination_token_address).await?;
    println!(
        "Destination Token Account Balance: {} tokens",
        destination_balance.base.amount
    );

    Ok(())

}
```