# CLOSE TOKEN ACCOUNT

# The CloseAccount Instructions permanently closes a token account and transfers all remaining SOL(rent) to a specific destination account
# The token account balance must be zero before closing. Only the token account owner or designated close authority  can execute this instruction

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};

use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, close_account},
    state::Mint,
};
#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //New keypair for the destination
    let destination = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;
    loop{
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //get default mint account size(in bytes), no extension enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //new account(mint)
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    )
    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(), 
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9, //decimals
    )?;

    //Calculate the associated token account address for the fee_payer
    let associated_token_address = get_associated_token_address_for_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );

    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );
    //Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,

    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    println!("Destination Address: {}", destination.pubkey());
    println!("Transaction Signature: {}", transaction_signature);
    //get the latest blockhash for the close transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Create close account instruction
    let close_instruction = close_account(
        &token_program_id(), //
        &associated_token_address, //Token account to close
        &destination.pubkey(), //Destination to receive SOl
        &fee_payer.pubkey(), //Owner of token account
        &[&fee_payer.pubkey()],
    )?;

    //Crate transaction for closing token account
    let transaction = Transaction::new_with_signed_payer(
        &[close_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("\nSuccessfully closed the token account");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //generate a new keypair for the fee payer
    let payer = Keypair::new();
    //Generate a new keypair for the destination
    let destination = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;

    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop{
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Create a new Program Client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    //number of decimals for the mint
    let decimals = 9;
    //Create Token client for the Token Program
    let token = Token::new(
        Arc::new(program_client),
       &token_program_id(),
       &mint.pubkey(),
       Some(decimals),
       Arc::new(payer.insecure_clone()),
    );

    //Create and Initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token
    .create_mint(
        &payer.pubkey(),//mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params //no extensions
        &[&mint], //mint keypair needed
    )
    .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Destination Address: {}", destination.pubkey());
    println!("Created Mint Account: {}", mint_result);

    //Derive the associated token account address
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    //Create the associated token account
    let create_ata_result = token
    .create_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;
    println!("Create Associated Token Account Address: {}", create_ata_result);
    //Close the token account
    let close_signature = token
    .close_account(
        &associated_token_address, //token account to close
        &destination.pubkey(), //destinationto receive SOL
        &payer.pubkey(), //owner of token account
        &[&payer] //signers,
    )
    .await?;

   println!("\nSuccessfully closed the token account.");
   println!("Transaction Signature: {}", transaction_signature);
    Ok(())

}
```
