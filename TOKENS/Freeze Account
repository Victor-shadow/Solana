# FREEZE ACCOUNT
# The FreezeAccount instruction prevents all token transfers or token burns from a specific token account.
# Once frozen, the account cannot send tokens, receive tokens, or be closed until thawed
# Only the freeze authority of the token mint, can freeze accounts. If the freeze authority, is revoked(set to null)
# on the mint account, tokens can never be frozen

``` rust 
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack;
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, mint_to, freeze_account},
    state::Mint,
};
#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),

    );
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Get default mint account size(in bytes), no extensions enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;
    //Instruction to create a new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //(new mint account)
        mint_rent //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    );
    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(), //program id
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9, //decimal
    )?;

    //calculate the associated token account
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program id
    );

    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );

    //Amount of tokens to mint(1000 tokens with 9 decimals)
    let amount = 1000_000_000_000;
    //Create mint_to instruction to mint tokens to the associated token account
    let mint_to_instruction = mint_to(
        &token_program_id(), //program id
        &mint.pubkey(), //mint
        &associated_token_address, //destination
        &fee_payer.pubkey(), //authority
        &[&fee_payer.authority()], //signer
        amount, //amount
    )?;

    //Create a transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
      &[
        create_account_instruction,
        initialize_mint_instruction,
        create_ata_instruction,
        mint_to_instruction,
      ],
      Some(&fee_payer.pubkey()),
      &[&fee_payer, &mint],
      latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);
    println!("Successfully minted 1000.0 tokens");

    //Get the latest blockhash for the freeze transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Create a freeze account instruction
    let freeze_instruction = freeze_account(
        &token_program_id(), //program id
        &associated_token_address, //token account to freeze
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //freeze authority
        &[&fee_payer.pubkey()], //signers
    )?;

    //Create transaction for freezing token account
    let transaction = Transaction::new_signed_with_payer(
        &[freeze_instruction],
        Some(&fee_payer.pubkey()), 
        &[&fee_payer],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("\nSuccessfully frozen the token account");
    println!("Transaction signature: {}", transaction_signature);

    Ok(()) 
}
```

# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};

use spl_token::id as token_program_id,
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Tokens},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
     rpc_client.confirm_transaction(&airdrop_signature).await?;

     loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
     }

     //Generate keypair to use as an address
     let mint = Keypair::new();

     //Create a new program client
     let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_confirmed(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
     );

     //Number of decimals for mint
     let decimals = 9;

     //Create a TokenClient  for the token program
     let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
     );

     //Create and initialize mint
     let extension_initialization_params: Vec<ExtesionInitializarionParams> = Vec::new();

     let mint_result = token
     .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params //no extensions
        &[&mint], //mint keypair needed as signer

     )
     .await?;

    println!("Mint Addresses: {}", mint.pubkey());
    println!("Mint Creation Result: {}", mint_result);

    //derive the associated token account address
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );

    //Create the associated token account
    let create_ata_result = token
    .create_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;

    println!("Created Associated Token Account: {}", create_ata_result);
    //Mint tokens to the associated token account
    let amount =  1000_000_000_000; //1000 tokens with 9 decimal places
    let mint_to_result = token
    .mint_to(
        &associated_token_address, //destination
        &payer.pubkey(), //mint authority
        amount, //amount
        &[&payer], //additional signers(providing payers  as a signer)
    )
    .await?;

     println!("Successfully minted 1000.0 tokens to associated token account");
     println!("Transaction Signature: {}", mint_to_result);

     //Freeze the token account
     let freeze_signature = token
     .freeze(
        &associated_token_address //token account to freeze
        &payer.pubkey(), //freeze authority
        &[&payer], //signers
     )
     .await?;

    println!("Successfully frozen the token account.");
    println!("Transaction Signature: {}", freeze_signature);
}
```