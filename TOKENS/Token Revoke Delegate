# TOKEN REVOKE DELEGATE

# The revoke delegate  instruction removes all transfer permissions from currently approved delegates. After revocation, the delegate can no longer transfer any tokens from one's account. Only the token account can revoke  a delegate

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
token::{ExtensionInitializationParams, Tokens},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the fee_payer
    let payer = Keypair::new();
    //Generate keypair for the delegate
    let delegate = Keypair::new();
    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;

    rpc_client.confirm_transaction(&airdrop_signature).await?;
    if confirmed{
        break;
    }
}

// Generate keypair to use as an address
let mint = Keypair::new();
//Create a new program client
let program_client = ProgramRpcClient::new(
    Arc::new(RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    )),
    ProgramRpcClientSendTransaction,
);

//Number of decimals for the mint
let decimals = 9;
//Create a TokenClient for the Token Program
let token = Token::new(
    Arc::new(program_client),
    &token_program_id(),
    &mint.pubkey(),
    Some(decimals),
    Arc::new(payer.insecure_clone()),
);

//Create and initialize the mint
let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

let mint_result = token
.create_mint(
    &payer.pubkey(),
    Some(&payer.pubkey()),
    extension_initialization_params,
    &[&mint],
)
.await?;
println!("Mint Address: {}", mint.pubkey());
println!("Created Mint Account: {}", mint_result);

//derive the associated token address
let associated_token_address = token.get_associated_token_address(&payer.pubkey());
println!(
    "\nAssociated Token Account Address: {}",
    associated_token_address
);

//Create associated token address
let create_ata_result = token
.create_associated_token_account(
    &payer.pubkey(), //owner
)
.await?;



println!("Created Associated Token Account: {}", create_ata_result);
//Mint associated tokens to the associated token account
let amount = 1000_000_000_000;
let mint_to_result = token
.mint_to(
    &associated_token_address, //destination
    &payer.pubkey(), //mint authority
    amount, //amount
    &[&payer] //additional signers
)
.await?;

println!("\nMinted 1000.0 tokens to an associated token account");
println!("Mint Transaction: {}", mint_to_result);

//Approve delegate to transfer one token
let delegate_amount = 1_000_000_000; //1.0 tokens with 9 decimals
let approve_result = token
.approve(
    &associated_token_address, //source accounts
    &delegate.pubkey(), //delegate
    &payer.pubkey(), //authority
    delegate_amount, //amount
    &[&payer], //signers
)
.await?;

println!("\nDelegate Address: {}", delegate.pubkey());
println!(
    "Successfully approved delegate to transfer 1.0 tokens"
);
println!("Transaction signature: {}", approve_result);
//revoke the delegation
let revoke_result = token
.revoke(
    &associated_token_address, //source account
    &payer.pubkey(), //authority
    &[&payer], //signer
)
.await?;

println!(
    "\n successfully revoked delegation from the token account"
);
println!("Transaction Signature: {}", revoke_result);

Ok(())
```

# Rust Async
``` rust
use solana_client::nonblocking::rpc_client::RpcClient;
use anyhow::Result;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack;
    signature::{Signer, Keypair},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,

};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, mint_to, approve_checked, revoke},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //Generate a keypair for the delegate
    let delegate = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop{
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if comfirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

    //Instruction to create a new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //mint account
        mint_rent //lamports
        mint_space as u64, //space
        &token_program_id(), //program_id

    );

    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(), //mint 
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()) //freeze authority
        9, //decimals
    )?;

    //Calculate the associated token account
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program_id
    );

    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program_id
    );

    //Amount of tokens to mint
    let amount = 1000_000_000_000;
    //Create mint_to instruction to mint tokens
    let mint_to_instruction = mint_to(
        &token_program_id(), 
        &mint.pubkey(), //mint
        &associated_token_address, //destination
        &fee_payer.pubkey(), //authority
        &[&fee_payer.pubkey()], //signer
        amount,
    )?;
    ///Amount of tokens to approve(1 token with 9 decimals)
    let approve_instruction = approve_checked(
        &token_program_id(), //program id
        &associated_token_address, //source token account
        &mint.pubkey(), //mint
        &delegate.pubkey(), //delegate
        &fee_payer.pubkey(), //owner
        &[&fee_payer.pubkey()], signers
        approve_amount, //amount
        9, //decimals
    )?;

    ///Create transaction and add instruction
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
            mint_to_instruction,
            approve_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Mint Address: {}", mint.pubkey());
    println!("Associated Token Account Address: {}", associated_token_address);

    println!("\nDelegate Address: {}", delegate.pubkey());
    println!("Successfully approved delegate to transfer 1.0 tokens");
    println!("Transaction Signature: {}", transaction_signature);
    //Get the latest blockhash for the revoke transaction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //revoke instruction
    let revoke_instruction = revoke(
        &token_program_id(), //program id
        &associated_token_address, //source token address
        &fee_payer.pubkey(), //owner
        &[&fee_payer.pubkey()], //signers
    )?;

    //Create transaction for revoking delegation
    let transaction = Transaction::new_signed_with_payer(
        &[revoke_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!(
        "\nSuccessfully revoked delegation from the token account"
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```