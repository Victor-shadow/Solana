# MINT TOKENS

# Minting creates a new unit of tokens using the MintTo Instructions
# Only the Mint authority can mint new tokens
# A destination token account must exist to receive the minted token

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,

};

use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, mint_to},
    state::Mint,  
}

#[tokio::main]
async fn main() -> Result<()>{
    //connection to local validator 
    let client = RpcClient::new_with_commitment(
        String::from("https://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let latest_blockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();

    //Airdrop 1 SOL to fee payer
    let airdrop_signature =client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();

    //Get default mint account size
    let mint_space = Mint::LEN,
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;

   //Instruction to create new account
   let create_account_instruction = create_account(
    &fee_payer.pubkey(), //payer
    &mint.pubkey(), //new account(mint)
    mint_rent, //lamports
    mint_space as u64, //space
    &token_program_id(), //program id
   );

   //Instruction to initialize mint account data
   let initialize_mint_instruction = initialize_mint(
    &token_program_id(),
    &mint.pubkey(), //mint
    &fee_payer.pubkey(), //mint authority
    Some(&fee_payer.pubkey()), //freeze authority
    2, //decimals
   )?;

   //Create the associated token account address
   let associated_token_address = get_associated_token_address_with_program_id(
    &fee_payer.pubkey(), //owner
    &mint.pubkey(), //mint
    &token_program_id(), //program_id,
   );

   //Instruction to create associated token account
   let create_ata_instruction = create_associated_token_account(
    &fee_payer.pubkey(),//funding address
    &fee_payer.pubkey(), //wallet address
    &mint.pubkey(), //mint address
    &token_program_id(), //program id
   );

   //Create transaction and add instructions
   let transaction = Transaction::new_signed_with_payer(
    &[
        create_account_instruction,
        initialize_mint_instruction,
        create_ata_instruction,
    ],
    Some(&fee_payer.pubkey()),
    &[&fee_payer, &mint],
    latestBlockhash,
   );

   //Send and confirm transaction
   let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

   println!("MintAddress: {}", mint.pubkey());
   println!(
    "Associated Token Account Address: {}",
    associated_token_address
   );

   println!("Transaction Signature: {}", transaction_signature);

   //Get the latest blockhash for the mint transaction
   let latestBlockhash = client.get_latest_blockhash().await?;

   //Amount of tokens to mint
   let amount = 100;
   //Create mint_to_instruction to mint tokens to the associated token account
   let mint_to_instruction = mint_to(
    &token_program_id(),
    &mint.pubkey(), //mint
    &associated_token_address, //destination
    &fee_payer.pubkey(), //authority
    &[&fee_payer.pubkey()], //signer
    amount, //amount
   )?;

   //Create transaction for minting token
   let transaction = Transaction::new_signed_with_payer(
    &[mint_to_instruction],
    Some(&fee_payer.pubkey()),
    &[&fee_payer],
    latestBlockhash,
   );

   //send and confirm transaction
   let transaction_signature= client.send_and_confirm_transaction(&transaction).await?;

   println!("Successfully minted 1.00 tokens to the associated token account");
   println!("Transaction Signature: {}", transaction_signature);

   Ok(())
}
```

# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};

use spl_token::id as token_program_id;
use spl_token::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},
};

use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),

    );

    //GENERATE A NEW KEYPAIR
    let payer = Keypair::new();

    //Airdrop 1 SOL to payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed{
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    //Number of decimals for the Mint
    let decimals = 2;
    //Create a token client for Token
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
    );

    //Create and Initialize the Mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params, //no extension
        &[&mint], //mint keypair needed as a signer
    )
    .await?;

     println!("Mint Address: {}", mint.pubkey());
     println!("Mint Creation Result: {}", mint_result);

     let associated_token_address = token.get_associated_token_address(&payer.pubkey());
     println!(
        "Derived Associated Token Account Address: {}",
        associated_token_address
     );

     //Create the associated token account
     let create_ata_result = token
     .create_associated_token_account(
        &payer.pubkey(); //owner
     )
     .await?;

     println!("Create Associated Token Account: {}", create_ata_result);
     //The associated token account has been created at the derived address
     println!("Associated token account created: {}", associated_token_address);

     //Mint Tokens to the associated tokens
     let amount = 100; // 100 tokens with 2 decimal places
     let mint_to_result = token
     .mint_to(
        &associated_token_address, //destination
        &payer.pubkey(), //authority(mint authority)
        amount, //amount
        &[&payer], //additional signers(payer as a signer)
     )
     .await?;

    println!("Minted {} tokens to associated token account", amount);
    println!("Mint Transaction: {}", mint__to_result);

    //Get token account balance to verify minting
    let balance = token.get_account_info(&associated_token_address).await?;
    println!("Token Account Balance : {} tokens", balance.base.amount);

    Ok(())
}
```