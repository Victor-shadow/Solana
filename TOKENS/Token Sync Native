# Sync Native SOL

#  Wrapped SOL(WSOL) is a token account that tracks the amounts of lamports in the account as a token balance
# WSOL enables integration with DeFi Protocols to transfer SOL as SPL token
# The SyncNative Instruction  synchronizes a wrapped SOL(WSOL) token account balance with the actual SOL (LAMPORTS) Stored in it. When one transfers Native SOL to a WSOL token account, the token balance does not automatically update. You must call sync native to reflect the correct WSOL Balance

``` Rust Async
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
    system_instruction::transfer as sol_transfer,
    transaction::Transaction,
};
use spl_associated_token_account::{
   get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};

use spl_token::{
    id as token program_id,
    instruction::sync_native,
    native_mint::ID as NATIVE_MINT_ID,
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client =RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Generate a new keypair for the fee_payer
    let fee_payer = Keypair::new();
    //Airdrop 2 sol to fee payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 2_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }
    //Calculate the associated token account address for WSOL
    let associated_token_address  = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &NATIVE_MINT_ID, //mint (Wrapped SOL)
        &token_program_id(), //program id
    );

    //Instruction to create associated token account for WSOL
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &NATIVE_MINT_ID, //mint address
        &token_program_id(), //program id,
    );

    //Amount to wrap(1 SOL = 1, 000, 000, 000 LAMPORTS)
    let amount = 1_000_000_000;

    //Create transfer instruction to send SOL to WSOL token account
    let transfer_instruction = sol_transfer(
        &fee_payer.pubkey(),
        &associated_token_address(),
        amount
    );
    //create sync native instruction to update native WSOL Balance
    let sync_native_instruction  = sync_native(
        &token_program_id(), //program id
        &associated_token_address
    )?;
    //Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_ata_instruction,
            transfer_instruction,
            sync_native_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        recent_blockhash,
    );

    //send and confirm transaction
    let transaction_signature  = client.send_and_confirm_transaction(&transaction).await?;


    println!("Fee Payer Address: {}", fee_payer.pubkey());
    println!(
        "WSOL Token Account Address: {}",
        associated_token_address
    );
    println!("Successfully wrapped 1 .0 SOL into WSOL");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
   commitment_config::CommitmentConfig,
   signature::{Keypair, Signer},
   system_instruction::transfer as sol_transfer,
   transaction::Transaction,
};
use spl_token::{id as token_program_id, native_mint::ID as NATIVE_MINT_ID};
use spl_token_client::{
   client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
   token::Token,
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the fee payer
    let payer = Keypair::new();
    //Airdrop 2 SOL to fee payer
    let airdrop_signature = rpc_client
    .request_airdrop(&payer.pubkey(), 2_000_000_000)
    .await?;

    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new-with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction, 
    );

    //Number of Decimals for WSOL
    let decimals = 9;
    //Create a token client for WSOL
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &NATIVE_MINT_ID,
        Some(decimals),
        Arc::new(payer.insecure_clone()), 
    );
    //derive the associated  token account address for WSOL
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "WSOL Token Account Address: {}",
        associated_token_address
    );

    //Create the associated token account for the WSOL
    let create_ata_result = token
    .create_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;

     println!("Created  WSOL Token Account: {}", create_ata_result);
     //Amount to WRAP(1 SOL = 1,000,000,000 lamports)
     let amount_to_sync = 1_000_000_000;

     //Transfer SOL into the created WSOL token account
     let transfer_instruction =  sol_transfer(
        &payer.pubkey(),
        &associated_token_address,
        amount_to_sync,
     );

     let mut transaction = Transaction::new_with_payer(
        &[transfer_instruction],
        Some(&payer.pubkey())
     );

     let recent_blockhash = rpc_client.get_recent_blockhash().await?;
     transaction.sign(&[&payer], recent_blockhash);

     let transactionSignature2  =rpc_client.send_and_confirm_transaction(&transaction).await?;
     println!("Transferred 1.0 SOL to WSOL token account");
     println!("Transfer Transaction Signature: {}", transactionSignature2);

     //sync the SOL into WSOL
     let transactionSignature3 = token.sync_native(&associated_token_address).await?;
     println!("Successfully wrapped 1.0 SOL into WSOL");
     println!("Sync Transaction Signature: {}", transactionSignature3);

     Ok(());  

}
```