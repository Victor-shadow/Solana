# The Thaw Account instruction Reverses a freeze restoring full functionality to a previously frozen token Account
# After thawing, the account can once again send and receive tokens normally
# Only the freeze authority of the token mint can thaw accounts

``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};

use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
}
use spl_token::{
    id as token program_id,
    instruction::{initialize_mint,mint_to, freeze_account, thaw_account},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()>{
    //Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let latesBlockhash = client.get_latest_blockhash().await?;

    //Generate new keypair for the fee payer
    let fee_payer = Keypair::new();
    //Airdrop 1 SOL to fee_payer
    let airdrop_signature = client
    .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
    .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature);
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //get default mint account size
    let mint_space = Mint::LEN;
    let mint_rent = client
    .get_minimum_balance_for_rent_exemption(mint_space)
    .await?;
    //Instruction to create new account
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), //payer
        &mint.pubkey(), //mint account
        mint_rent, //lamports
        mint_space as u64, //space
        &token_program_id(), //program id
    );

    //Instruction to initialize mint account
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(), //program id
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //mint authority
        Some(&fee_payer.pubkey()), //freeze authority
        9, //decimals
    )?;

    //calculate the associated token account address for fee payer
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(), //owner
        &mint.pubkey(), //mint
        &token_program_id(), //program_id

    );

    //Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), //funding address
        &fee_payer.pubkey(), //wallet address
        &mint.pubkey(), //mint address
        &token_program_id(), //program id
    );

    //Amount of tokens to mint(1000 tokens with 9 decimals)
    let amount = 1000_000_000_000;
    //Create mint_to instruction to mint tokens to the associated token account
    let mint_to_instruction = mint_to(
        &token_program_id(), 
        &mint.pubkey(), //mint
        &associated_token_address, //destination
        &fee_payer.pubkey(), //authority
        &[&fee_payer.pubkey()], //signer
        amount, //amount
    )?;

    //Create freeze account instructions
    let freeze_instruction = freeze_account(
        &token_program_id(), //program id
        &associated_token_address, //token account to freeze
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //freeze authority
        &[&fee_payer.pubkey()], //signers
    )?;

    //Create transaction and add instructions
    let transactions = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
            mint_to_instruction,
            freeze_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,

    );

    //send and confirm transaction
    let transaction_signature  = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Associated Token Account Address",
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);
    println!("Successfully minted 1000.0 tokens and frozen the account");
    //Get the latest blockhash for the thaw instruction
    let latestBlockhash = client.get_latest_blockhash().await?;
    //Create a thaw account instruction
    let thaw_instruction = thaw_account(
        &token_program_id(),//program id
        &associated_token_address(), //token account to thaw
        &mint.pubkey(), //mint
        &fee_payer.pubkey(), //freeze authority
        &[&fee_payer.pubkey()], //signers
    )?;

    //Create a transaction for thawing token account
    let transaction = Transaction::new_signed_with_payer(
        &[thaw_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );
    //send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Successfully thawed the frozen token account:");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

# TOKEN CLIENT
``` rust
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};

use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    token::{ExtensionInitializationParams, Token},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()>{
    //create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    //Generate a new keypair for the fee_payer
    let payer = Keypair::new();
    //Airdrop 1 SOL to fee payer
    let airdrop_signature = client.
    request_airdrop(&payer.pubkey(), 1_000_000_000)
    .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    //Generate keypair to use as an address
    let mint = Keypair::new();
    //Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    //Number of decimals for the mint
    let decimals = 9;
    //Create a token client for the Token Program
    let token = Token::new(
       Arc::new(program_client),
       &token_program_id(), //program id
       &mint.pubkey(),
       Some(decimals),
       Arc::new(payer.insecure_clone()),
    );

    //Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result  = token
    .create_mint(
        &payer.pubkey(), //mint authority
        Some(&payer.pubkey()), //freeze authority
        extension_initialization_params //no extensions
        &[&mint] //mint keypair needed as signer
    )
    .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Mint Creation Result: {}", mint_result);

    //derive the associated token account address
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );

    //Create the associated token account
    let create_ata_result = token
    .create_associated_token_account(
        &payer.pubkey(), //owner
    )
    .await?;

   println!("Created Associated Token Account: ", create_ata_result);

   //Mint tokens to the associated token account
   let amount = 1000_000_000_000; //1000 tokens with 9 decimal places
   let mint_to_result = token
   .mint_to(
    &associated_token_address, //destination
    &payer.pubkey(), //mint authority
    amount, //amount
    &[&payer], //additional signer(provide payer as signer)
   )
   .await?;

  println!("Successfully minted 1000.0 tokens to associated token account");
  println!("Transaction Signature: ", mint-to_result);

  //Freeze the token account
  let freeze_signature = token
  .freeze(
    &associated_token_address, //token account to freeze
    &payer.pubkey(), //freeze authority
    &[&payer], //signers
  ) 
  .await?; 
   println!("Successfully frozen the token account");
   println!("Transaction Signature: ", freeze_signature);
   //Thaw the frozen token account
   let thaw_signature = token
   .thaw(
    &associated_token_address, //thaw token account
    &payer.pubkey(), //freeze authority
    &[&payer] //signers
   )
   .await?;
   
   println!("Successfully thawed the frozen token account");
   println!("Transaction Signature: {}", thaw_signature);

   Ok(())
}
```