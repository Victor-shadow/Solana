# PROGRAM DERIVED ADDRESSES

# Program Derived Addresses are a feature of Solana Development that serves two main use cases:
# 1: Deterministic Account Addresses: Program Derived Addresses provide a mechanism to deterministically create an address using a combination of optional "seeds"(predefined inputs) and a specific Program ID
# 2: Enable Program Signing: The Solana runtime enables programs to "sign in" for Program Derived Addresses which are derived from the program address

# Program Derived Addresses are a way to create HashMap like structures on-chain from a pre-defined set of inputs(strings, numbers, other account addresses)
# The benefit of this approach is that it eliminates the need  to keep track of an exact address. Instead,  one needs to recall specific inputs used for its derivation



#                                             Accounts
# findProgramAddress(seeds, programId)        Key                           Value
#                                             Wallet Public Key             Account
#                                             ProgramId                     Account
#                                             PDA                           Account


# Deriving a Program Derived Address does not automatically create an on-chain account at that address
# Accounts with a PDA as the on-chain address must be explicitly created through the program used to derive the address
# Deriving a Program Derived Address is as finding an address on a Map

# KEY POINTS
# 1: PDA's are addresses derived deterministically using a combination of predefined seeds, a bump seed, and a Program's ID.
# 2: PDA's are addresses that fall off the Ed25519 curve and have no corresponding private key
# 3: Solana Program's can sign on behalf of PDA's derived from its ProgramID
# 4: Deriving a PDA does not automatically create an on-chain account
# 5: An account using a PDA as its address must be created through an instruction within a Solana Program

# Definition of a Program Derived Address:
# PDA's are addresses that look like public keys, but have no private keys. This means it is not possible to generate a valid signature for the address
# However, the Solana runtime enables programs to "sign" for Program Derived Addresses without needing a private key
# For Context, Solana Keypairs are points on the Ed25519 curve(Elliptic Curve cryptography) with a public key and corresponding private key
# Public keys are used as addresses(unique identifier) for on-chain accounts

# A PDA is a point that is intentionally derived to fall off the Ed25519 curve using a pre-defined set of inputs. A point that is not on the Ed25519 curve does not have a valid corresponding private key and can't perform cryptographic operations(signing)
# A PDA can serve as the address(unique identifier) for an on-chain account, providing a method to easily store, map and fetch program state

# Derive PDA
# The derivation of PDA requires three inputs:

# 1: Optional seeds: Predefined Inputs(.g strings, number, other account addresses) for 
# PDA derivation
# 2: Bump Seed: An Extra byte, appended to the optional seeds to ensure a valid PDA(off curve) is generated. The bump seed starts at 255 and decrements by 1 until a valid PDA is found
# 3: Program ID:  The Address of the program from which the PDA is derived. The Program can sign on behalf of the PDA

----------------------------------------------------------------------------------------------------

#                        findProgramAddress(optional seeds, programId)

#                                 bump=255

#                        createProgramAddress(optional seeds + bump, programId)

#                             Valid PDA Found    -> NO

#                                  Yes

#                             return(PDA, bump)
----------------------------------------------------------------------------------------------------

# Use the following functions from the respective SDK's to derive a PDA
# SDK                                          FUNCTION
# solana_sdk(Rust)                             find_program_address

# To Derive Program Derived Address provide the following inputs to the SDK function:

# 1: The predefined optional seeds converted to bytes
# 2: The Program ID(address) used for derivation

# Once a valid Program Derived Address is found, the function returns both the Address(PDA) and the bump seed used for derivation

```rust
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()>{
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    let seeds: &[&[u8]] = &[b"helloWorld"];

    let (pda, bump) = Pubkey::find_program_address(seeds,&program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

# OPTIONAL ADDRESS SEED
``` rust
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()>{
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())

}

```

# Program Derived Addresses with multiple optional seeds
``` rust
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()>{
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed_bytes = b"HelloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);

    Ok(())
}
```

# PDA derivation requires a "bump seed", an extra byte appended to the optional seeds. The derivation function iterates through bump values, starting at 255 and decrementing by one, until a value produces a valid-off curve address. The first bump value that produces a valid-off curve address is a "canonical bump"

``` rust
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()>{
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"HelloWorld";

    //Loop through all bump seeds
    for bump in (0..=255).rev(){
        match Pubkey::create_program_address(&[optional_seed.as_ref(),&[bump]], &program_id){
            Ok(pda) => println!("Bump {}: {}", bump, pda );
            Err(err) => println!("Bump {}: {}", bump, err);
        }
    }

    Ok(())
}

```

# The bump seed 255 throws an error and the first bump seed to derive a valid PDA is 254
# bump seeds 253-251 all derive valid PDAs with different addresses. This means that given the same optional seeds and programId, a bump Seed with a different value can still derive a valid PDA

# NOTE: When Building Solana Programs, always include security checks to ensure a PDA passed to the program is derived from the canonical bump

# CREATE PROGRAM DERIVED ADDRESSES ACCOUNTS
# A single initialize instruction to create a new account using PDA as the address of the account
# The new account stores the address of the user and the bump seed used to derive the PDA

``` rust
use anchor_lang::prelude::*;
declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx:Context<Initialize>) -> Result<()>{
        let account_data = &mut ctx.accounts.pda_account;
        //store the address of the 'User'
        account_data.user = *ctx.accounts.user.key;
        //store the canonical bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initializer<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
  ///The seeds for PDA derivation include the fixed string data and the address of the user account
  /// provided in the instruction
  /// The Anchor framework automatically finds the canonical bump seed
    #[account(
        init, /// Instructs Anchor to invoke the System Program to create a new account using the PDA as the address. Anchor does this through CrossProgramInvocation
        //define the seeds to derive the PDA
        seeds = [b"data", user.key().as_ref()],
        //use canonical bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]

    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

# The test file contains Typescript code to derive the PDA
``` typescript
const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publickey.toBuffer()],
    program.programId,
);

```

# The transaction in the test file invokes the initialize instruction to create a new on-chain account using the Program Derived Address as the address
# Anchor can infer the PDA Address in the instruction accounts, so it does not need to be explicitly provided

``` typescript
it("Is Initialized!", async () => {
    const transactionSignature = await program.methods
    .initialize()
    .accounts({
        user: user.publicKey,
    })
    .rpc();

    console.log("Transaction Signature:", transactionSignature);
});
```

# The test file also shows how fetch the on-chain account created at that address once the transaction is sent

``` typescript
it("Fetch Account", async () => {
const pdaAccount = await program.account.dataAccount.fetch(PDA);
console.log(JSON.stringify(pdaAccount, null , 2));
});

```

# NOTE: IF ONE INVOKES INITIALIZE INSTRUCTION MORE THAN ONCE USING THE SAME USER ADDRESS AS SEED, THEN THE TRANSACTION FAILS. THIS HAPPENS AS THE ACCOUNT ALREADY EXISTS IN THE DERIVED ADDRESS


